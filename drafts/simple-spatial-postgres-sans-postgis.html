<!DOCTYPE html>
<html lang="en">

<head>
      <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>Earthdistance and Cube: Simple, Fast, Approximate Spatial PostgreSQL Without&nbsp;PostGIS</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href=".." rel="canonical" />

  <!-- Feed -->

  <link href="../theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="../theme/css/code_blocks/github.css" rel="stylesheet">


  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


    <link href="../drafts/simple-spatial-postgres-sans-postgis.html" rel="canonical" />

        <meta name="description" content="Postgresql has builtin types and features allowing you to do basic geospatial work — storing and querying by latitude / longitude boxes...">

        <meta name="author" content="James Robinson">

        <meta name="tags" content="PostgreSQL">
        <meta name="tags" content="PostGIS">

        <meta property="og:locale" content="" />
    <meta property="og:site_name" content="James on Programming" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="James on Programming" />
    <meta property="og:description" content="View the blog." />
    <meta property="og:url" content=".." />
      <meta property="og:image" content="..//static/moonman.jpeg" />

  <meta property="og:type" content="article">
            <meta property="article:author" content="../author/james-robinson.html">
  <meta property="og:url" content="../drafts/simple-spatial-postgres-sans-postgis.html">
  <meta property="og:title" content="Earthdistance and Cube: Simple, Fast, Approximate Spatial PostgreSQL Without&nbsp;PostGIS">
  <meta property="article:published_time" content="2019-05-24 00:00:00-04:00">
            <meta property="og:description" content="Postgresql has builtin types and features allowing you to do basic geospatial work — storing and querying by latitude / longitude boxes...">

            <meta property="og:image" content="..//static/moonman.jpeg">
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>
          <li><a href="https://github.com/jlrobins" role="presentation">Personal Github</a></li>
          <li><a href="http://jlr-photo.com/" role="presentation">Photo Site</a></li>

              <li role="presentation"><a href="../category/postgresql-python">PostgreSQL-Python</a></li>

    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="post-header" class="has-cover">
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href=".." title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">Earthdistance and Cube: Simple, Fast, Approximate Spatial PostgreSQL Without&nbsp;PostGIS</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="../author/james-robinson.html">James robinson</a>
            | <time datetime="Fri 24 May 2019">Fri 24 May 2019</time>
        </span>
        <!-- TODO : Modified check -->
        
            <div class="post-cover cover" style="background-image: url('/static/moonman.jpeg')">            
        
      </div>
    </header>    

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <h1><span class="caps">GIS</span> in PostgreSQL without&nbsp;PostGIS?</h1>
<p><a href="https://postgis.net/">PostGIS</a> is a <a href="https://postgis.net/features/">fantastic</a> open-source 3rd party extension for full geospatial work in PostgreSQL. If you&#8217;re not <span class="caps">GIS</span>-minded, however, and just want to do basic operations with the lat/long points you&#8217;ve gotten from either geocoding addresses or, say, from <span class="caps">EXIF</span> data embedded in pictures, then you may well be intimidated in traversing PostGIS&#8217;s documentation to figure out how to do the small subset of things you&#8217;re looking to do, especially starting with &#8220;<em>what does all this <span class="caps">SRID</span> stuff mean?</em>&#8221;</p>
<p>If you need to relate your geocodes to <strong>arbitrary shapes</strong> like geopolitical boundaries, then PostGIS is where it&#8217;s at. No avoiding it. But if you just need to just as efficiently store and query your points, say, in terms of <em>within a radius of an arbitrary lat/long</em>, or <em>within a rectangle described by a pair of lat/long</em>, or perhaps find what 10 lat/long points you&#8217;ve got which are <em>nearest</em> to an arbitrary point (<em>K-nearest-neighbors</em>, aka <strong><span class="caps">KNN</span></strong>), then you can dive right in with stock PostgreSQL, leaving you with fewer dependencies and a simpler overall working system. And plus, at any time in the future, if/when you realize you need functionality that only PostGIS can provide, then upgrading your data to be managed and queried by PostGIS is just some legwork and a schema migration or two away. Until then, you may want to err on following <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it"><span class="caps">YAGNI</span></a>.</p>
<p>In this multi-part series, we&#8217;ll explore what can and cannot be done with pretty much vanilla PostgreSQL, then also show how to smoothly upgrade the schema to use PostGIS, migrate the data from the builtin PostgreSQL datatypes to PostGIS types, and then do some fancier things that you can only do in&nbsp;PostGIS.</p>
<h2>Geometric Types and&nbsp;PostgreSQL</h2>
<p>One of the core raison d&#8217;être&#8217;s of the PostgreSQL codebase, coming from its <a href="https://en.wikipedia.org/wiki/Ingres_(database)">foundational implementation <span class="caps">INGRES</span></a> and intermediate implementation PostGRES, was to <a href="http://db.cs.berkeley.edu/papers/ERL-M85-95.pdf">support rich data types</a> (<em><span class="caps">PDF</span></em>), including easily user-defined types. Project founder Michael Stonebreaker&#8217;s team received funding for developing a relational database to support computer aided design work, leading to geometric types like points, lines, circles, and boxes being a part of the codebase for&nbsp;decades.</p>
<p>These <a href="https://www.postgresql.org/docs/current/datatype-geometric.html">types</a> and the <a href="https://www.postgresql.org/docs/current/functions-geometry.html">functions and operators</a> are well documented, but what is lacking is a little bit of glue work and the knowledge of indexing types in order to put together a working system, as well as knowing what these types can and cannot do for you. In this article, I&#8217;m going to imagine that we&#8217;re working on a photo sharing website / database, as inspired by <a href="https://www.reddit.com/r/PostgreSQL/comments/br1tac/should_i_use_postgis/">this reddit question</a>.</p>
<p>We&#8217;ll start by working with vanilla (to PostgreSQL!) types <code>point</code>, <code>box</code>, and <code>circle,</code> then will introduce an arbitrary-dimensional <code>cube</code> type provided by the <a href="https://www.postgresql.org/docs/current/cube.html"><code>cube</code></a> extension. Note that this <code>cube</code> is a type representing an arbitrary-dimensioned box in a coordinate space, <strong>not</strong> a cube as in <a href="https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-GROUPING-SETS">Grouping Sets, Cube, and Rollup</a> <span class="caps">OLAP</span> functionality.&nbsp;Ugh.</p>
<h2>Geocodes as&nbsp;Points</h2>
<p>Latitude and Longitude name a point on earth using polar coordinates, with latitude measuring the degrees north of the equator and longitude being degrees west of Greenwich, England. Degrees latitude are given the range -90º (south pole) to +90º (north pole), while degrees longitude are measured from 0º to -180º going west from Greenwich, through the Atlantic and North America to the polar opposite of Greenwich, the <em>anti-meridian</em>. The eastern hemisphere is measured in positive degree values from 0º to +180º. Two formats can be used, either decimal degrees as already described, or degree / minute / seconds (<em><span class="caps">DMS</span></em>), in which a directional indicator (N, S, E, W) stands in place of +/-, with minutes being 1/60 of a degree, and seconds being 1/60 of a&nbsp;minute.</p>
<p>We will be storing lat/long in <code>point</code> columns, but beware: human convention is to refer to these two in <code>(y, x)</code> order (<em>latitude is the y value</em>), but Cartesian coordinate convention is <code>(x, y)</code>, so we must take care to reverse when storing, and then again when presenting as lat/long&nbsp;values.</p>
<p>Furthermore, since <span class="caps">DMS</span> is used in the <span class="caps">EXIF</span> standard, we&#8217;ll also need to be aware of how to convert those values to decimal degrees for storage &#8212; a job best done by whatever code you&#8217;d be using on the front- or middle-tier to process JPEGs and extract the <span class="caps">EXIF</span>. <a href="https://developer.here.com/blog/getting-started-with-geocoding-exif-image-metadata-in-python3">This blog post</a> does a nice job covering how you can extract <span class="caps">EXIF</span> tags and then convert from <span class="caps">DMS</span> to decimal degrees in python. We&#8217;ll be skipping those parts and just talk&nbsp;PostgreSQL.</p>
<p>The PostgreSQL point datatype stores a pair of floating point values, interpreted as an X and a Y in some sort of Cartesian plane. You can extract or manipulate either component using array index notation, with X being <code>[0]</code>, and Y being <code>[1]</code>:</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="nb">point</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">3</span><span class="p">);</span>
<span class="go"> point</span>
<span class="go">-------</span>
<span class="go"> (0,3)</span>
<span class="go">(1 row)</span>

<span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="s1">&#39;(3.234, 4.2343)&#39;</span><span class="o">::</span><span class="nb">point</span><span class="p">;</span>
<span class="go">     point</span>
<span class="go">----------------</span>
<span class="go"> (3.234,4.2343)</span>
<span class="go">(1 row)</span>
</pre></div>


<p>To extract X or Y while also providing an inlined point, we&#8217;ve got to use an extra layer of parenthesis in order to appease the grammar, regardless of which constructor flavor&nbsp;used:</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="p">(</span><span class="nb">point</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">3</span><span class="p">))[</span><span class="mf">0</span><span class="p">];</span>
<span class="go"> point</span>
<span class="go">-------</span>
<span class="go">     0</span>
<span class="go">(1 row)</span>

<span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="p">(</span><span class="nb">point</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="mf">3</span><span class="p">))[</span><span class="mf">1</span><span class="p">];</span>
<span class="go"> point</span>
<span class="go">-------</span>
<span class="go">     3</span>
<span class="go">(1 row)</span>


<span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="p">(</span><span class="s1">&#39;(0,3)&#39;</span><span class="o">::</span><span class="nb">point</span><span class="p">)[</span><span class="mf">1</span><span class="p">];</span>
<span class="go"> point</span>
<span class="go">-------</span>
<span class="go">     3</span>
<span class="go">(1 row)</span>
</pre></div>


<p>Let&#8217;s imagine we&#8217;re working on a photo gallery website. We&#8217;re going to store the filename as found in a 3-layer deep directory hierarchy, the image width and height, and then the image&#8217;s geocode as extracted from the <span class="caps">EXIF</span> using a <code>point</code> column. Imagine other metadata also stored, perhaps in a <code>jsonb</code> column corresponding to all of the rest of the <span class="caps">EXIF</span>&nbsp;&#8230;</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">create</span> <span class="k">table</span> <span class="n">image</span>
<span class="p">(</span>
    <span class="n">id</span> <span class="nb">serial</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>

    <span class="n">filename</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span> <span class="k">unique</span><span class="p">,</span>

    <span class="c1">-- Primary metadata</span>
    <span class="n">width</span> <span class="nb">int</span> <span class="k">not</span> <span class="k">null</span>
        <span class="k">check</span> <span class="p">(</span><span class="n">width</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">),</span>
    <span class="n">height</span> <span class="nb">int</span> <span class="k">not</span> <span class="k">null</span>
        <span class="k">check</span> <span class="p">(</span><span class="n">height</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">),</span>

    <span class="c1">-- Imagine from EXIF metadata, converted from DMS to decimal degrees</span>
    <span class="c1">-- longitude (X) and latitude (Y) ...</span>
    <span class="n">geocode_point</span> <span class="nb">point</span>
        <span class="k">constraint</span> <span class="n">sane_longitude</span> <span class="k">check</span> <span class="p">(</span>
                    <span class="n">geocode_point</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="k">between</span> <span class="o">-</span><span class="mf">180</span> <span class="k">and</span> <span class="mf">180</span>
        <span class="p">),</span>
        <span class="k">constraint</span> <span class="n">sane_latitude</span> <span class="k">check</span> <span class="p">(</span>
                    <span class="n">geocode_point</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="k">between</span> <span class="o">-</span><span class="mf">90</span> <span class="k">and</span> <span class="mf">90</span>
        <span class="p">),</span>

    <span class="c1">-- other / all metadata ...</span>
    <span class="n">exif</span> <span class="nb">jsonb</span>
<span class="p">);</span>

<span class="go">CREATE TABLE</span>

<span class="gp">poor_gis=#</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">image</span>
  <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">geocode_point</span><span class="p">)</span>
<span class="k">values</span>
  <span class="p">(</span><span class="s1">&#39;/a/a/345sdf.jpg&#39;</span><span class="p">,</span> <span class="mf">200</span><span class="p">,</span> <span class="mf">500</span><span class="p">,</span> <span class="s1">&#39;(1,4)&#39;</span> <span class="p">),</span> <span class="c1">-- will get id 1,</span>
  <span class="p">(</span><span class="s1">&#39;/a/b/654sdg.jpg&#39;</span><span class="p">,</span> <span class="mf">600</span><span class="p">,</span> <span class="mf">900</span><span class="p">,</span> <span class="s1">&#39;(3,7)&#39;</span> <span class="p">),</span> <span class="c1">-- 2, ...</span>
  <span class="p">(</span><span class="s1">&#39;/a/c/765gdf.jpg&#39;</span><span class="p">,</span> <span class="mf">1200</span><span class="p">,</span> <span class="mf">1200</span><span class="p">,</span><span class="s1">&#39;(23.43, -34.44)&#39;</span> <span class="p">),</span>
  <span class="p">(</span><span class="s1">&#39;/a/d/8354gdfg.jpg&#39;</span><span class="p">,</span> <span class="mf">1375</span><span class="p">,</span> <span class="mf">966</span><span class="p">,</span><span class="s1">&#39;(-23, 55)&#39;</span> <span class="p">),</span>
  <span class="p">(</span><span class="s1">&#39;/a/e/76dfg.jpg&#39;</span><span class="p">,</span> <span class="mf">3455</span><span class="p">,</span> <span class="mf">5220</span><span class="p">,</span> <span class="s1">&#39;(-129.234, -67.34)&#39;</span> <span class="p">)</span>
<span class="p">;</span>

<span class="go">INSERT 0 5</span>

<span class="go">-- Row(s) where X is negative, i.e in the western hemisphere ...</span>
<span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">image</span> <span class="k">where</span> <span class="n">geocode_point</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0</span><span class="p">;</span>
<span class="go"> id |     filename      | width | height |   geocode_point   | exif</span>
<span class="go">----+-------------------+-------+--------+-------------------+------</span>
<span class="go">  4 | /a/d/8354gdfg.jpg |  1375 |    966 | (-23,55)          |</span>
<span class="go">  5 | /a/e/76dfg.jpg    |  3455 |   5220 | (-129.234,-67.34) |</span>


<span class="go">-- Rows where Y is &gt; 10, i.e. 10º north of equator ...</span>
<span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">image</span> <span class="k">where</span> <span class="n">geocode_point</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">10</span><span class="p">;</span>

<span class="go"> id |     filename      | width | height | geocode_point | exif</span>
<span class="go">----+-------------------+-------+--------+---------------+------</span>
<span class="go">  4 | /a/d/8354gdfg.jpg |  1375 |    966 | (-23,55)      |</span>
<span class="go">(1 row)</span>
</pre></div>


<p>Excellent, simple basics are&nbsp;sane.</p>
<p>Let&#8217;s make things more interesting by adding one million more rows with equally random metadata, which we&#8217;ll start to query against after a sidebar. The main complexity here is coming up with the random filenames&nbsp;&#8230;</p>
<div class="highlight"><pre><span></span><span class="k">do</span> <span class="s">$$</span>
    <span class="k">declare</span>
        <span class="n">chars</span> <span class="nb">text</span><span class="p">[]</span> <span class="o">=</span>
            <span class="s1">&#39;{a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}&#39;</span><span class="p">;</span>

        <span class="n">num_chars</span> <span class="nb">int</span> <span class="o">:=</span> <span class="n">array_length</span><span class="p">(</span><span class="n">chars</span><span class="p">,</span> <span class="mf">1</span><span class="p">);</span>
        <span class="n">num_nums</span> <span class="nb">int</span> <span class="o">:=</span> <span class="mf">10</span><span class="p">;</span>

        <span class="n">filename</span> <span class="nb">text</span><span class="p">;</span>

        <span class="n">i</span> <span class="nb">int</span><span class="p">;</span> <span class="n">j</span> <span class="nb">int</span><span class="p">;</span>
    <span class="k">begin</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1..1000000</span>
        <span class="k">loop</span>

            <span class="c1">-- Make realistic-ish filenames per above!</span>
            <span class="c1">-- Ala &quot;/g/e/dfgdfger.jpg&quot;</span>
            <span class="n">filename</span> <span class="o">:=</span>    <span class="s1">&#39;/&#39;</span> <span class="o">||</span> <span class="n">chars</span><span class="p">[</span><span class="mf">1</span><span class="o">+</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">num_chars</span><span class="o">-</span><span class="mf">1</span><span class="p">)]</span>
                        <span class="o">||</span> <span class="s1">&#39;/&#39;</span> <span class="o">||</span> <span class="n">chars</span><span class="p">[</span><span class="mf">1</span><span class="o">+</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">num_chars</span><span class="o">-</span><span class="mf">1</span><span class="p">)]</span>
                        <span class="o">||</span> <span class="s1">&#39;/&#39;</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mf">1..7</span> <span class="k">loop</span>
                <span class="n">filename</span> <span class="o">:=</span> <span class="n">filename</span> <span class="o">||</span> <span class="n">chars</span><span class="p">[</span><span class="mf">1</span><span class="o">+</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">num_chars</span><span class="o">-</span><span class="mf">1</span><span class="p">)];</span>
            <span class="k">end</span> <span class="k">loop</span><span class="p">;</span>

            <span class="n">filename</span> <span class="o">:=</span> <span class="n">filename</span> <span class="o">||</span> <span class="s1">&#39;.jpg&#39;</span><span class="p">;</span>

            <span class="k">insert</span> <span class="k">into</span> <span class="n">image</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">geocode_point</span><span class="p">)</span>
            <span class="k">values</span> <span class="p">(</span>
                <span class="n">filename</span><span class="p">,</span>

                <span class="c1">-- Schizophrenic aspect ratios be damned!</span>
                <span class="mf">1</span><span class="o">+</span><span class="p">(</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="mf">6400</span><span class="p">)</span><span class="o">::</span><span class="nb">int</span><span class="p">,</span> <span class="c1">-- width</span>
                <span class="mf">1</span><span class="o">+</span><span class="p">(</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="mf">3200</span><span class="p">)</span><span class="o">::</span><span class="nb">int</span><span class="p">,</span> <span class="c1">-- height</span>

                <span class="nb">point</span><span class="p">(</span>
                    <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">360</span> <span class="o">-</span> <span class="mf">180</span><span class="p">,</span> <span class="c1">-- [-180 -&gt; +180]</span>
                    <span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">180</span> <span class="o">-</span> <span class="mf">90</span> <span class="c1">-- [-90 -&gt; +90]</span>
                <span class="p">)</span>
            <span class="p">);</span>

        <span class="k">end</span> <span class="k">loop</span><span class="p">;</span>

    <span class="k">end</span><span class="p">;</span>
<span class="s">$$</span><span class="p">;</span>
</pre></div>


<p>We need to be sure to analyze the table after the 1M rows are inserted to ensure that the planner statistics are aware that this is a <em>big</em> table now. Otherwise if you were to run the subsequent queries, even after crafty indices have been created, if the planner&#8217;s statistics still showed the table as having only a handful of rows in a single block, then the index could well be ignored, given that a sequential scan through a handful of blocks is always going to be faster than doing random access through an index, then going back to the table (heap) file doing random access through the named blocks if the overall row / block count in the table is low. The autovacuum service is going to update the statistics for you sometime in the near future asynchronously, but you might well have pasted the subsequent index creation and queries before it ran, which would then confuse even the best of&nbsp;us.</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">analyze</span> <span class="n">image</span><span class="p">;</span>
<span class="go">ANALYZE</span>
</pre></div>


<p>PostgreSQL has a <a href="https://www.postgresql.org/docs/current/functions-geometry.html#FUNCTIONS-GEOMETRY-OP-TABLE">rich set of operators</a> atop its geometric types, including points. For our examples, we&#8217;ll focus on a few binary&nbsp;operators:</p>
<ul>
<li>Distance Between: <code>&lt;-&gt;</code> (Euclidean distance between operands at their closest&nbsp;points)</li>
<li>Overlaps: <code>&amp;&amp;</code> (any point in common between left hand side and right hand&nbsp;side?)</li>
<li>Contains: <code>@&gt;</code> (left side completely contains right&nbsp;side?)</li>
<li>Contained By: <code>&lt;@</code> (left side completely contained by right&nbsp;side?)</li>
<li>Is Strictly Right of: <code>&lt;&lt;</code> (all X values in <span class="caps">LHS</span> less than all X values in <span class="caps">RHS</span>?)</li>
<li>Is Strictly Left of: <code>&gt;&gt;</code> (all X values in <span class="caps">LHS</span> greater than all X values in <span class="caps">RHS</span>?)</li>
<li>Is Strictly Below: <code>&lt;&lt;|</code> (all Y values in <span class="caps">LHS</span> less than all Y values in <span class="caps">RHS</span>?)</li>
<li>Is Strictly Above: <code>&gt;&gt;|</code> (all Y values in <span class="caps">LHS</span> greater than all Y values in <span class="caps">RHS</span>?)</li>
</ul>
<p>When working with points as one of the two operands, there&#8217;s no semantic difference between using the Overlaps or either flavor of the Contains operators, since a point is either both or neither contained and overlapping, never only one of&nbsp;those.</p>
<p>PostgreSQL operators can be end-user-defined, and pre-defined ones may vary in meaning per datatype. You will find a somewhat different set of operators and/or verbose function names when cross-comparing between PostGIS and these basic builtin geometric&nbsp;operators.</p>
<p>Let&#8217;s rephrase our &#8220;Row(s) where X is negative&#8221; query, but this time comparing the stored points with a literal point, using the &#8216;Is Strictly Left Of&#8217;&nbsp;operator:</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">image</span> <span class="k">where</span> <span class="n">geocode_point</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;(0, 0)&#39;</span><span class="p">;</span>
<span class="go"> count</span>
<span class="go">--------</span>
<span class="go"> 499894</span>
<span class="go">(1 row)</span>
</pre></div>


<p>Cool, querying points given a point. <em>(Your randomly built data will vary, of course, but we do expect around half a million&nbsp;rows)</em></p>
<h2>Real-world Use Case #1: <strong>Points Within&nbsp;Box</strong></h2>
<p>We can do fancier queries &#8212; like, say, asking for points &#8220;within a box.&#8221; A native PostgreSQL <code>box</code> is a rectangle defined by the coordinates of two opposite&nbsp;corners:</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
            <span class="k">from</span> <span class="n">image</span>
            <span class="k">where</span> <span class="n">geocode_point</span> <span class="o">&lt;@</span> <span class="s1">&#39;(10, 10), (20, 20)&#39;</span><span class="o">::</span><span class="nb">box</span><span class="p">;</span>

<span class="go"> count</span>
<span class="go">-------</span>
<span class="go">  1575</span>
<span class="go">(1 row)</span>
</pre></div>


<p>This is a <em>very common</em> <span class="caps">GIS</span> operation: &#8220;What geographic features do I have within arbitrary corners of a lat/long rectangle, <a href="https://developers.google.com/maps/documentation/javascript/reference/map#Map.getBounds">such as the rectangle described by the viewport of a Google Maps window</a>?&#8221;</p>
<p>Now, how did PostgreSQL come up with the ~1,500 out of 1M rows this&nbsp;time?</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
            <span class="k">from</span> <span class="n">image</span>
            <span class="k">where</span> <span class="n">geocode_point</span> <span class="o">&lt;@</span> <span class="s1">&#39;(10, 10), (20, 20)&#39;</span><span class="o">::</span><span class="nb">box</span><span class="p">;</span>

<span class="go">                                      QUERY PLAN</span>
<span class="go">---------------------------------------------------------------------------------</span>
<span class="go"> Finalize Aggregate  (cost=15555.62..15555.63 rows=1 width=8)</span>
<span class="go">  -&gt;  Gather  (cost=15555.40..15555.61 rows=2 width=8)</span>
<span class="go">      Workers Planned: 2</span>
<span class="go">      -&gt;  Partial Aggregate  (cost=14555.40..14555.41 rows=1 width=8)</span>
<span class="go">            -&gt;  Parallel Seq Scan on image  (cost=0.00..14554.36 rows=417 width=0)</span>
<span class="go">                Filter: (geocode_point &lt;@ &#39;(20,20),(10,10)&#39;::box)</span>
<span class="go">(6 rows)</span>
</pre></div>


<p>It did so by performing a <strong>Parallel Seq Scan</strong> &#8212; splitting the table up into chunks (2 in this case), then having workers filter every row in each assigned chunk against the operator. That is, it examined all 1M rows in the table. Boo! <em>Inefficient!</em></p>
<p>We can make this efficient using the <em>same</em> technology PostGIS would: a <a href="https://www.postgresql.org/docs/current/indexes-types.html">space-partitioning GiST index</a>. In the case of <span class="caps">SP</span>-GiST indexing the <code>point</code> type, we will create a multi-dimensional index similar to an <a href="https://en.wikipedia.org/wiki/R-tree">R-tree</a>, which optimizes queries for multi-dimensional datatypes.
<em>(To be more precise, a space-partitioning quad tree is created
in PostgreSQL&#8217;s <a href="https://github.com/postgres/postgres/blob/master/src/backend/utils/adt/geo_spgist.c">src/backend/utils/adt/geo_spgist.c</a>)</em></p>
<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">create</span> <span class="k">index</span> <span class="n">image_geocode_point_idx</span> <span class="k">on</span> <span class="n">image</span> <span class="k">using</span> <span class="n">gist</span><span class="p">(</span><span class="n">geocode_point</span><span class="p">);</span>
<span class="go">CREATE INDEX</span>
</pre></div>


<p>Repeating the query, we now get an entirely different&nbsp;plan:</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">explain</span> <span class="k">select</span> <span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
            <span class="k">from</span> <span class="n">image</span>
            <span class="k">where</span> <span class="n">geocode_point</span> <span class="o">&lt;@</span> <span class="s1">&#39;(10, 10), (20, 20)&#39;</span><span class="o">::</span><span class="nb">box</span><span class="p">;</span>

<span class="go">                            QUERY PLAN</span>
<span class="go">-------------------------------------------------------------------------</span>
<span class="go"> Aggregate  (cost=35.28..35.29 rows=1 width=8)</span>
<span class="go">   -&gt;  Index Only Scan using image_geocode_point_idx on image</span>
<span class="go">              (cost=0.29..32.78 rows=1000 width=0)</span>
<span class="go">        Index Cond: (geocode_point &lt;@ &#39;(20,20),(10,10)&#39;::box)</span>
<span class="go">(3 rows)</span>
</pre></div>


<p>This plan uses an entirely different algorithm: a single worker accesses the <span class="caps">SP</span>-GiST index for the rows matching the &#8220;<em>contained by box</em>&#8221; expression. It just so happens that <a href="https://www.postgresql.org/docs/current/indexes-index-only-scans.html">all of the requirements for only needing to consult the index, and not also the heap file</a> are met, resulting in choosing to use the Index Only Scan algorithm. This results in <em>far, far less I/O</em>, be it between storage and <span class="caps">RAM</span>, or even between <span class="caps">RAM</span> and L1/L2/L3 cache, and even between L1 cache and registers. Most database operations are I/O bound, so reducing any sort of I/O means reducing <em>time to complete</em>.</p>
<p>How do times compare? Here&#8217;s the <code>EXPLAIN ANALYZE</code> results, showing timings and actual visited rows, not just expected rowcounts, from before the index was&nbsp;created:</p>
<div class="highlight"><pre><span></span> <span class="n">Finalize</span> <span class="k">Aggregate</span> <span class="p">(</span><span class="k">cost</span><span class="o">=</span><span class="mf">15555.62..15555.63</span> <span class="k">rows</span><span class="o">=</span><span class="mf">1</span> <span class="n">width</span><span class="o">=</span><span class="mf">8</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mf">49.587..49.587</span> <span class="k">rows</span><span class="o">=</span><span class="mf">1</span> <span class="n">loops</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
   <span class="o">-&gt;</span>  <span class="n">Gather</span>  <span class="p">(</span><span class="k">cost</span><span class="o">=</span><span class="mf">15555.40..15555.61</span> <span class="k">rows</span><span class="o">=</span><span class="mf">2</span> <span class="n">width</span><span class="o">=</span><span class="mf">8</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mf">49.482..50.770</span> <span class="k">rows</span><span class="o">=</span><span class="mf">3</span> <span class="n">loops</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
         <span class="n">Workers</span> <span class="n">Planned</span><span class="p">:</span> <span class="mf">2</span>
         <span class="n">Workers</span> <span class="n">Launched</span><span class="p">:</span> <span class="mf">2</span>
         <span class="o">-&gt;</span>  <span class="k">Partial</span> <span class="k">Aggregate</span>
                    <span class="p">(</span><span class="k">cost</span><span class="o">=</span><span class="mf">14555.40..14555.41</span> <span class="k">rows</span><span class="o">=</span><span class="mf">1</span> <span class="n">width</span><span class="o">=</span><span class="mf">8</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mf">44.629..44.629</span> <span class="k">rows</span><span class="o">=</span><span class="mf">1</span> <span class="n">loops</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
               <span class="o">-&gt;</span>  <span class="n">Parallel</span> <span class="n">Seq</span> <span class="n">Scan</span> <span class="k">on</span> <span class="n">image</span>
                        <span class="p">(</span><span class="k">cost</span><span class="o">=</span><span class="mf">0.00..14554.36</span> <span class="k">rows</span><span class="o">=</span><span class="mf">417</span> <span class="n">width</span><span class="o">=</span><span class="mf">0</span><span class="p">)</span>
                            <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mf">0.134..44.534</span> <span class="k">rows</span><span class="o">=</span><span class="mf">525</span> <span class="n">loops</span><span class="o">=</span><span class="mf">3</span><span class="p">)</span>
                     <span class="k">Filter</span><span class="p">:</span> <span class="p">(</span><span class="n">geocode_point</span> <span class="o">&lt;@</span> <span class="s1">&#39;(20,20),(10,10)&#39;</span><span class="o">::</span><span class="nb">box</span><span class="p">)</span>
                     <span class="k">Rows</span> <span class="n">Removed</span> <span class="k">by</span> <span class="k">Filter</span><span class="p">:</span> <span class="mf">332810</span>
 <span class="n">Planning</span> <span class="nb">Time</span><span class="p">:</span> <span class="mf">0.138</span> <span class="n">ms</span>
 <span class="n">Execution</span> <span class="nb">Time</span><span class="p">:</span> <span class="mf">50.831</span> <span class="n">ms</span>
<span class="p">(</span><span class="mf">10</span> <span class="k">rows</span><span class="p">)</span>
</pre></div>


<p>Each of the two parallel seq scan workers visited hundreds of thousands of rows, removing the vast majority which fail the filter expression. Since the dataset sits inside <span class="caps">RAM</span> on this machine, it still ends up operating very quickly: <em>51ms</em>.</p>
<p>After the index,&nbsp;though:</p>
<div class="highlight"><pre><span></span> <span class="k">Aggregate</span>  <span class="p">(</span><span class="k">cost</span><span class="o">=</span><span class="mf">35.28..35.29</span> <span class="k">rows</span><span class="o">=</span><span class="mf">1</span> <span class="n">width</span><span class="o">=</span><span class="mf">8</span><span class="p">)</span>
                <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mf">0.865..0.865</span> <span class="k">rows</span><span class="o">=</span><span class="mf">1</span> <span class="n">loops</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
   <span class="o">-&gt;</span>  <span class="k">Index</span> <span class="k">Only</span> <span class="n">Scan</span> <span class="k">using</span> <span class="n">image_geocode_point_idx</span> <span class="k">on</span> <span class="n">image</span>
            <span class="p">(</span><span class="k">cost</span><span class="o">=</span><span class="mf">0.29..32.78</span> <span class="k">rows</span><span class="o">=</span><span class="mf">1000</span> <span class="n">width</span><span class="o">=</span><span class="mf">0</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">actual</span> <span class="nb">time</span><span class="o">=</span><span class="mf">0.077..0.673</span> <span class="k">rows</span><span class="o">=</span><span class="mf">1575</span> <span class="n">loops</span><span class="o">=</span><span class="mf">1</span><span class="p">)</span>
         <span class="k">Index</span> <span class="n">Cond</span><span class="p">:</span> <span class="p">(</span><span class="n">geocode_point</span> <span class="o">&lt;@</span> <span class="s1">&#39;(20,20),(10,10)&#39;</span><span class="o">::</span><span class="nb">box</span><span class="p">)</span>
         <span class="n">Heap</span> <span class="n">Fetches</span><span class="p">:</span> <span class="mf">0</span>
 <span class="n">Planning</span> <span class="nb">Time</span><span class="p">:</span> <span class="mf">0.188</span> <span class="n">ms</span>
 <span class="n">Execution</span> <span class="nb">Time</span><span class="p">:</span> <span class="mf">0.917</span> <span class="n">ms</span>
<span class="p">(</span><span class="mf">6</span> <span class="k">rows</span><span class="p">)</span>
</pre></div>


<p>Same results, but the <span class="caps">SP</span>-GiST index gives it to us in <em>1/55th</em> of the execution&nbsp;time.</p>
<p>A <span class="caps">SP</span>-GiST index is <em>exactly the same sort of technology PostGIS uses to &#8220;make spatial queries go fast.&#8221;</em> As you can see here, it isn&#8217;t a feature limited to PostGIS! This is out-of-the-box PostgreSQL. In fact, the PostGIS indexing code <a href="http://postgis.net/docs/doxygen/2.5/da/dbb/gserialized__spgist__2d_8c_source.html">is extremely similar</a> to the PostgreSQL core implementation we saw&nbsp;earlier.</p>
<p>So, imagine the website includes a Google map window. Scrolling and zooming through the Google map window produces a new latitude / longitude bounding box. You could then fire off an <span class="caps">AJAX</span> request with the bounding box coordinates to your middleware, which then returns both the count of pictures and the count of distinct geocodes for said pictures taken within the viewport. If either number is sufficiently low, then your <span class="caps">AJAX</span> results could not only include the count, but also the list of metadata and filenames for the contained pictures. Your front-end code could then plot markers on the map for the pictures. Selecting a marker could display the picture at that&nbsp;point!</p>
<p>This <span class="caps">SP</span>-GiST index&#8217;s utility isn&#8217;t limited to &#8220;things inside or overlapping a box&#8221; (which is exactly what a <em>bounding-box</em> comparison is). We can do &#8220;points within a circle&#8221; easily also. Circles in vanilla PostgreSQL are <a href="https://www.postgresql.org/docs/current/datatype-geometric.html#DATATYPE-CIRCLE">described by a center point and a radius</a>:</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">explain</span> <span class="k">analyze</span> <span class="k">select</span> <span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">image</span>
                       <span class="k">where</span> <span class="n">geocode_point</span> <span class="o">&lt;@</span> <span class="s1">&#39;((15, 15), 5)&#39;</span><span class="o">::</span><span class="nb">circle</span><span class="p">;</span>

<span class="go"> Aggregate  (cost=35.28..35.29 rows=1 width=8)</span>
<span class="go">                 (actual time=0.609..0.609 rows=1 loops=1)</span>
<span class="go">   -&gt;  Index Only Scan using image_geocode_point_idx on image</span>
<span class="go">                 (cost=0.29..32.78 rows=1000 width=0)</span>
<span class="go">                              (actual time=0.076..0.488 rows=1212 loops=1)</span>
<span class="go">         Index Cond: (geocode_point &lt;@ &#39;&lt;(15,15),5&gt;&#39;::circle)</span>
<span class="go">         Heap Fetches: 0</span>
<span class="go"> Planning Time: 0.075 ms</span>
<span class="go"> Execution Time: 0.636 ms</span>
<span class="go">(6 rows)</span>
</pre></div>


<p>Fast? Yes. Used our same index? Yes. But, <em>meaningful</em>? To determine that, we&#8217;ll first stroll through some <span class="caps">GIS</span> and coordinate system mapping details, as well as introduce the other sort of geographic query solvable within non-PostGIS PostgreSQL&nbsp;&#8230;</p>
<h2>K Nearest&nbsp;Neighbors</h2>
<p>Querying for &#8220;<em>what is close to this point</em>&#8221; is a very common need with spatial datasets, and would be especially useful in our semi-contrived photograph explorer web application. Let the user either type in an address (then to be geocoded), or select an arbitrary point on the map, and then, say, pull back the <em>nearest 15 pictures to that point</em>. A query to do that would just need an &#8220;order by <em>distance-from-this-point</em> limit K&#8221; clause. But alas, <strong>determining the distance between polar earth coordinate pairs</strong> isn&#8217;t quite so&nbsp;simple&#8230;</p>
<h3>Lat/Long versus Aspect Ratio And Great Circle&nbsp;Distances</h3>
<p>One thing the astute may notice is that the range of degrees east / west (-180º &lt;-&gt; +180º: 360º total) is twice that of north / south (-90º &lt;-&gt; +90º: 180º total). This means we&#8217;ve got sort of a non-square <em>aspect ratio</em> &#8212; even excluding that we&#8217;ve got polar coordinates naming points on a sphere. If we were dealing with purely Cartesian coordinates, one unit north/south is equivalent to two units east/west &#8212; both are exactly 1/90th of the range. Therefore an actual square box (<em>again, currently interpreting as if Cartesian and not polar coordinates</em>) would need to be 2x wide as it is tall in order to be actually &#8220;square&#8221;. A box that reads &#8220;square&#8221; actually casts a rectangle over this most-simple projection: <code>'(0,0), (1, 1)'::box</code> covers twice the latitudinal range as it does longitudinally (aka &#8220;<em>is twice as tall as it is wide</em>&#8220;). You could, if you wish, correct for this by casting for a pre-adjusted rectangle by dividing the width in half: <code>'(0,0), (.5, 1)'::box</code>.</p>
<p>Likewise, to cast a &#8220;true circle&#8221; over this warped projection, you&#8217;d need to actually cast a pre-adjusted ellipse. Unfortunately, here&#8217;s an area where vanilla PostgreSQL types for bull-headed non-PostGIS geographic database applications falls short: there&#8217;s no ellipse&nbsp;type!</p>
<p>To make matters worse, once you begin to consider additional literal <em>real world</em> factors&nbsp;like:</p>
<ol>
<li>The number of miles (or meters, or whatever linear measurement) in a degree longitude depends on what <em>latitude</em> you&#8217;re at, even with a purely spherical earth model. If you&#8217;re a hair&#8217;s breadth north of the south pole, walking a degree west is trivial (well, by <em>trivial</em>, I mean <em>100 meters in any direction is a real slog, very different from a walk in the park</em>), but at the equator, traveling 1 degree due west means walking 69 miles (again, assuming the earth is truly spherical, with a radius of ~3,958 miles). Fortunately, the distorted warping is minimal where most of us live, the tropics of Cancer and Capricorn, so we can usually determine the conversion factor given a single latitude in a query and then use the single result when determining how to adjust the bounding box when accessing a spatial&nbsp;index.</li>
<li>The earth isn&#8217;t truly spherical, but instead bulges at the equator due to centrifugal force. Modeling the earth much more accurately requires projecting the polar coordinates onto the surface of an <em>oblate spheroid</em>.</li>
<li>The Earth isn&#8217;t just an oblate spheroid, but has mountains and valleys. One mile west-&gt;east as the crow flies across Yosemite valley, from El Capitan across to Half Dome is a much shorter path than what a walking and rock-climbing human or ant must cover to travel in the crow&#8217;s exact shadow at noon. Meanwhile, a mile west-&gt;east in Kansas is much closer to a stroll in the&nbsp;park.</li>
<li>The Earth isn&#8217;t static, but is made up of slowly moving continental plates. Features within the same plate tend to stay the same distance from each other, but will be drifting in unison relative to features in other plates. This drift is slow, but definitely happens. This makes large-scale earth measurements skew over time &#8212; the distance from New York to London is growing about an inch a year due to the <a href="https://pubs.usgs.gov/gip/dynamic/understanding.html">split in the mid-Atlantic ridge</a>, but New York is <em>not</em> getting closer to Los&nbsp;Angeles.</li>
</ol>
<p>&#8230; then you realize that it isn&#8217;t quite so simple to ask for &#8220;all geocodes in database within some number of linear miles from this arbitrary geocode&#8221; if you want to be <em>accurate</em>.</p>
<p>PostgreSQL bundled extension <a href="https://www.postgresql.org/docs/current/earthdistance.html"><code>earthdistance</code></a> models factor <strong>1</strong>&#8216;s spherical earth by implementing functions and operators for determining the <a href="https://en.wikipedia.org/wiki/Great-circle_distance"><em>great cicle distance</em></a> (<em>distance along the surface, instead of a straight line tunneling through the interior</em>) between points on the surface of the earth for two different datatypes: the one we&#8217;ve been using up to now, <code>point</code>, interpreting the point&#8217;s X and Y as two-dimensional polar degrees longitude and latitude on the surface of a <em>purely spherical</em> earth, and a new datatype / representation provided by a separate bundled extension, <a href="https://www.postgresql.org/docs/current/cube.html"><code>cube</code></a>. The <code>earthdistance</code> <code>cube</code> representation projects points on a purely spherical earth as three dimensional points in space centered at the middle of a perfectly spherical (and not spinning) earth. In the cube representation, a single 3-d point would either be in space, on the surface of the earth, or in the interior of the planet. The module provides a <em>domain</em> over <code>cube</code>, <code>earth</code>, which constraints a cube to be a 3-space point generally near the surface of the earth, as measured in whatever units the function named <code>earth()</code> returns. The module&#8217;s default implementation of the <code>earth()</code> function returns 6,378,168 (meters). If you would prefer to work in miles instead, you may just redefine this function to to return miles, as&nbsp;in:</p>
<div class="highlight"><pre><span></span><span class="k">create</span> <span class="k">or</span> <span class="k">replace</span> <span class="k">function</span> <span class="n">earth</span><span class="p">()</span>
    <span class="k">returns</span> <span class="k">float</span> <span class="k">immutable</span> <span class="n">parallel</span> <span class="n">safe</span>
    <span class="k">as</span> <span class="s1">&#39;select 3658.8::float&#39;</span> <span class="k">language</span> <span class="n">sql</span><span class="p">;</span>
</pre></div>


<p>We&#8217;ll leave things be here, however, and just make use of the default implementation returning ~ six million&nbsp;meters.</p>
<p>Ignoring all this talk about <code>cube</code> and so forth to start with, let&#8217;s try the one operator the extension provides for &#8216;great circle distance in miles between two points, <strong><code>point &lt;@&gt; point</code></strong>, described at the very bottom of the <a href="https://www.postgresql.org/docs/current/earthdistance.html#id-1.11.7.22.6"><code>earthdistance</code> extension&#8217;s documentation</a>. This operator looks similar to the builtin <strong><code>point &lt;-&gt; point</code></strong> operator returning the Euclidean distance (you know, Pythagoras&#8217;s theorem and whatnot), but accounts for the polar coordinate nature of the point coordinates, the &#8220;aspect ratio&#8221; disparity between longitude and latitude values, and for also traveling along the curvature of a sphere instead of a straight line through the earth. The original operator we played with, <strong><code>point &lt;-&gt; point</code></strong>, is <em>only accurate for Cartesian coordinates on a flat plane</em> or for <a href="https://www.tfes.org/">certain freethinkers</a>.</p>
<p>Let&#8217;s compare the results of asking for the closest pictures near a spot in Kansas. First, using the wrong operator, assuming a flat plane and Cartesian coordinates&nbsp;&#8230;</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="n">geocode_point</span><span class="p">,</span>
    <span class="n">geocode_point</span> <span class="o">&lt;-&gt;</span> <span class="nb">point</span><span class="p">(</span><span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">,</span> <span class="mf">48.6482342518866</span><span class="p">)</span>
                                        <span class="k">as</span> <span class="n">flat_earth_radian_distance</span>
    <span class="k">from</span> <span class="n">image</span>
    <span class="k">order</span> <span class="k">by</span> <span class="n">geocode_point</span> <span class="o">&lt;-&gt;</span> <span class="nb">point</span><span class="p">(</span><span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">,</span> <span class="mf">48.6482342518866</span><span class="p">)</span>
    <span class="k">limit</span> <span class="mf">5</span><span class="p">;</span>

<span class="go">   id   |            geocode_point             | flat_earth_radian_distance</span>
<span class="go">--------+--------------------------------------+----------------------------</span>
<span class="go"> 598209 | (-89.9676686525345,48.6067019216716) |          0.119530605833611</span>
<span class="go"> 515449 | (-89.9886091612279,48.6989216320217) |          0.142353443267662</span>
<span class="go"> 220796 | (-89.7144250385463,48.9332739450037) |          0.318078456991974</span>
<span class="go"> 141547 | (-89.6269739605486,48.8807080127299) |          0.326047985932906</span>
<span class="go"> 499558 | (-89.5203682221472,48.6719857994467) |          0.336057680731329</span>

<span class="go">(5 rows)</span>
</pre></div>


<p>And now the results when using the <em>more accurate</em> great circle distance operator, first installing both <code>earthdistance</code> and its dependency, <code>cube</code>:</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">create</span> <span class="k">extension</span> <span class="n">cube</span><span class="p">;</span>
<span class="go">CREATE EXTENSION</span>
<span class="gp">poor_gis=#</span> <span class="k">create</span> <span class="k">extension</span> <span class="n">earthdistance</span><span class="p">;</span>
<span class="go">CREATE EXTENSION</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="n">geocode_point</span><span class="p">,</span>
    <span class="n">geocode_point</span> <span class="o">&lt;@&gt;</span> <span class="nb">point</span><span class="p">(</span><span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">,</span> <span class="mf">48.6482342518866</span><span class="p">)</span>
                                    <span class="k">as</span> <span class="n">spherical_earth_distance_miles</span>
    <span class="k">from</span> <span class="n">image</span>
    <span class="k">order</span> <span class="k">by</span> <span class="n">geocode_point</span> <span class="o">&lt;@&gt;</span> <span class="nb">point</span><span class="p">(</span><span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">,</span> <span class="mf">48.6482342518866</span><span class="p">)</span>
    <span class="k">limit</span> <span class="mf">5</span><span class="p">;</span>

<span class="go">   id   |            geocode_point             | spherical_earth_distance_miles</span>
<span class="go">--------+--------------------------------------+--------------------------------</span>
<span class="go"> 598209 | (-89.9676686525345,48.6067019216716) |               5.86804759696775</span>
<span class="go"> 515449 | (-89.9886091612279,48.6989216320217) |               7.00722296641611</span>
<span class="go"> 499558 | (-89.5203682221472,48.6719857994467) |                15.386314146465</span>
<span class="go"> 141547 | (-89.6269739605486,48.8807080127299) |               19.1416237881716</span>
<span class="go"> 220796 | (-89.7144250385463,48.9332739450037) |               20.7159950259304</span>
<span class="go">(5 rows)</span>
</pre></div>


<p>Interesting! The difference in distance measurement algorithms produces different results against this random test data! Images 598209 and 515449 are the closest under either metric, but the ordering of the remainders vary according to the metric used. Again, the great-circle metric as performed by <code>&lt;@&gt;</code> is &#8220;<em>better</em>&#8221; and more accurate&nbsp;here.</p>
<p>The <em>values</em> for the distance operators certainly look different. In the first example, since our points are in decimal degrees radian, the distance between points are also in radians, but in arbitrary (and unspecified by this query) directions. The second example gives us statute miles at least, a much more meaningful value. <span class="caps">KNN</span> queries often don&#8217;t care about the actual distance between neighbors, just who the neighbors are, but seeing the values is informative in this&nbsp;case.</p>
<p>Let&#8217;s see the plans, however&nbsp;&#8230;</p>
<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">explain</span> <span class="k">analyze</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">image</span>
  <span class="k">order</span> <span class="k">by</span> <span class="n">geocode_point</span> <span class="o">&lt;-&gt;</span> <span class="nb">point</span><span class="p">(</span><span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">,</span> <span class="mf">48.6482342518866</span><span class="p">)</span>
  <span class="k">limit</span> <span class="mf">5</span><span class="p">;</span>

<span class="go"> Limit  (cost=0.29..0.52 rows=5 width=53)(actual time=0.150..0.176 rows=5 loops=1)</span>
<span class="go">   -&gt;  Index Scan using image_geocode_point_idx on image</span>
<span class="go">                    (cost=0.29..47670.89 rows=1000005 width=53)</span>
<span class="go">                            (actual time=0.148..0.173 rows=5 loops=1)</span>
<span class="go">    Order By: (geocode_point &lt;-&gt; &#39;(-89.8555855080485,48.6482342518866)&#39;::point)</span>
<span class="go"> Planning Time: 0.171 ms</span>
<span class="go"> Execution Time: 0.228 ms</span>
<span class="go">(5 rows)</span>
</pre></div>


<p>Awesome. The <span class="caps">SP</span>-GiST index we created previously has our back&nbsp;here.</p>
<p>What about the performance of the more accurate&nbsp;query?</p>
<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">explain</span> <span class="k">analyze</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">image</span>
  <span class="k">order</span> <span class="k">by</span> <span class="n">geocode_point</span> <span class="o">&lt;@&gt;</span> <span class="nb">point</span><span class="p">(</span><span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">,</span> <span class="mf">48.6482342518866</span><span class="p">)</span>
  <span class="k">limit</span> <span class="mf">5</span><span class="p">;</span>


<span class="go"> Limit  (cost=22475.11..22475.69 rows=5 width=53)</span>
<span class="go">                (actual time=161.691..163.953 rows=5 loops=1)</span>
<span class="go">   -&gt;  Gather Merge  (cost=22475.11..119704.66 rows=833338 width=53)</span>
<span class="go">                            (actual time=161.690..163.949 rows=5 loops=1)</span>
<span class="go">         Workers Planned: 2</span>
<span class="go">         Workers Launched: 2</span>
<span class="go">         -&gt;  Sort  (cost=21475.08..22516.75 rows=416669 width=53)</span>
<span class="go">                            (actual time=156.645..156.646 rows=4 loops=3)</span>
<span class="go">              Sort Key: ((geocode_point</span>
<span class="go">                            &lt;@&gt; &#39;(-89.8555855080485,48.6482342518866)&#39;::point))</span>
<span class="go">              Sort Method: top-N heapsort  Memory: 26kB</span>
<span class="go">              Worker 0:  Sort Method: top-N heapsort  Memory: 26kB</span>
<span class="go">              Worker 1:  Sort Method: top-N heapsort  Memory: 26kB</span>
<span class="go">              -&gt;  Parallel Seq Scan on image</span>
<span class="go">                            (cost=0.00..14554.36 rows=416669 width=53)</span>
<span class="go">                                (actual time=0.028..95.691 rows=333335 loops=3)</span>
<span class="go"> Planning Time: 0.155 ms</span>
<span class="go"> Execution Time: 163.994 ms</span>
<span class="go">(12 rows)</span>
</pre></div>


<p><strong>Whaaaat?</strong> No fancy index support?? Well, given that the <strong><code>point &lt;@&gt; point</code></strong> operator did not even exist in our database when we created index image_geocode_point_idx, we ought not be too surprised. Perhaps all that talk about <code>cube</code> in <code>earthdistance</code> has some merit? Especially the part reading &#8220;<em>&#8230; In addition, a cube GiST index can be used to find nearest neighbors using the metric operators &lt;-&gt;, &lt;#&gt;, and &lt;=&gt; in <span class="caps">ORDER</span> <span class="caps">BY</span> clauses. For example, the nearest neighbor of the 3-D point (0.5, 0.5, 0.5) could be found efficiently with &#8230;</em>&#8221;</p>
<p>So &#8212; let&#8217;s try with a second index, a <em>functional</em> one cross-converting our stored points in latitude and longitude to cube / earth points in 3-space, then <span class="caps">KNN</span> querying using the <strong><code>cube &lt;-&gt; cube</code></strong> operator in the <code>order by</code> clause. Function <code>ll_to_earth(longitude float, latitude float)</code> converts lat/long to an <code>earth</code> aka <code>cube</code> point in 3-space. <em>Sigh, <code>ll_to_earth</code> wants its parameters in latitude, longitude order, so invert our lovely (X, Y) pairs as we decompose&nbsp;&#8230;</em></p>
<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">create</span> <span class="k">index</span> <span class="n">image_geocode_as_cube</span>
    <span class="k">on</span> <span class="n">image</span>
    <span class="k">using</span> <span class="n">gist</span><span class="p">(</span><span class="n">ll_to_earth</span><span class="p">(</span><span class="n">geocode_point</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span> <span class="n">geocode_point</span><span class="p">[</span><span class="mf">0</span><span class="p">]));</span>

<span class="go">CREATE INDEX</span>
</pre></div>


<p>Now let&#8217;s try an equivalent <span class="caps">KNN</span> query, but this time given the distance from converting our Kansas lat/long to an <code>earth</code> / <code>cube</code> (and passing lat, long in the right order both&nbsp;invocations):</p>
<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="n">geocode_point</span><span class="p">,</span>
    <span class="n">ll_to_earth</span><span class="p">(</span><span class="n">geocode_point</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span> <span class="n">geocode_point</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
        <span class="o">&lt;-&gt;</span> <span class="n">ll_to_earth</span><span class="p">(</span><span class="mf">48.6482342518866</span><span class="p">,</span> <span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">)</span>
                <span class="k">as</span> <span class="n">cube_threespace_distance_meters</span>
 <span class="k">from</span> <span class="n">image</span>
  <span class="k">order</span> <span class="k">by</span>
    <span class="n">ll_to_earth</span><span class="p">(</span><span class="n">geocode_point</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span> <span class="n">geocode_point</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
        <span class="o">&lt;-&gt;</span> <span class="n">ll_to_earth</span><span class="p">(</span><span class="mf">48.6482342518866</span><span class="p">,</span> <span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">)</span>
  <span class="k">limit</span> <span class="mf">5</span><span class="p">;</span>

<span class="go">    id   |            geocode_point             | cube_threespace_distance_meters</span>
<span class="go">--------+--------------------------------------+---------------------------------</span>
<span class="go"> 598209 | (-89.9676686525345,48.6067019216716) |                9454.35088669499</span>
<span class="go"> 515449 | (-89.9886091612279,48.6989216320217) |                 11289.741773158</span>
<span class="go"> 499558 | (-89.5203682221472,48.6719857994467) |                24789.7673198475</span>
<span class="go"> 141547 | (-89.6269739605486,48.8807080127299) |                 30840.150001606</span>
<span class="go"> 220796 | (-89.7144250385463,48.9332739450037) |                33376.7027558878</span>
<span class="go">(5 rows)</span>
</pre></div>


<p>Excellent, it matches the expected results as determined by <em>fancy-pants</em> operator <strong><code>point &lt;@&gt; point</code></strong>. What about the&nbsp;plan?</p>
<div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">explain</span> <span class="k">analyze</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">image</span>
  <span class="k">order</span> <span class="k">by</span>
    <span class="n">ll_to_earth</span><span class="p">(</span><span class="n">geocode_point</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span> <span class="n">geocode_point</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
        <span class="o">&lt;-&gt;</span> <span class="n">ll_to_earth</span><span class="p">(</span><span class="mf">48.6482342518866</span><span class="p">,</span> <span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">)</span>
  <span class="k">limit</span> <span class="mf">5</span><span class="p">;</span>


<span class="go"> Limit  (cost=0.41..1.91 rows=5 width=85)(actual time=0.517..0.715 rows=5 loops=1)</span>
<span class="go">   -&gt;  Index Scan using image_geocode_as_cube on image</span>
<span class="go">                (cost=0.41..300280.76 rows=1000005 width=85)</span>
<span class="go">                        (actual time=0.516..0.713 rows=5 loops=1)</span>
<span class="go">    Order By: ((ll_to_earth(geocode_point[1],</span>
<span class="go">            geocode_point[0]))::cube</span>
<span class="go">                &lt;-&gt; &#39;(10621.2320983345, -4213915.6225754, 4787883.5983624)&#39;::cube)</span>
<span class="go"> Planning Time: 0.361 ms</span>
<span class="go"> Execution Time: 0.804 ms</span>
<span class="go">(5 rows)</span>
</pre></div>


<p><strong>Booyah!</strong> Same order of magnitude as using the (wrong) Euclidean distance comparison! Our downside is that we&#8217;ve now got two different indices to store and update, plus very different looking <span class="caps">KNN</span>-ish query style than we have for our bounding-box query. For these 1M rows, the indexes weigh&nbsp;&#8230;</p>
<div class="highlight"><pre><span></span># select relname, pg_size_pretty(pg_relation_size(oid))
  from pg_class
  where relname like &#39;image_geocode%&#39;;

         relname         | pg_size_pretty
-------------------------+----------------
 image_geocode_as_cube   | 83 MB
 image_geocode_point_idx | 71 MB
(2 rows)
</pre></div>


<p>Not too bad overall for 1M geocodes, but the table size itself is only <span class="caps">73MB</span>, so we&#8217;ve tripled our storage costs. Your level of distaste for a pair of indices over two rather different representations of geocodes may vary,&nbsp;but:</p>
<ol>
<li>We will be using the geocodes of our images in lat/long form when we display. Keeping them immediately available is&nbsp;paramount.</li>
<li>We have a major use case of displaying all image points which fall inside a reasonably-zoomed map window. Said map window will be in terms of a lat/long box, so being able to query using the box coordinates is simplest and fastest against the <span class="caps">SP</span>-GiST index atop those 2D&nbsp;points.</li>
<li>Our other use case, determining an accurate-enough ordering of the actual pictures nearest to an arbitrary point requires a better, <em>spherical</em>, model of the earth for a better value of <code>accurate-enough</code>.</li>
</ol>
<p>Let&#8217;s examine the difference between the simple Cartesian distance versus the great circle distance for a larger number of points to see where things start to break down in my sample dataset. The windowing function <a href="https://www.postgresql.org/docs/current/functions-window.html"><code>rank()</code></a>, invoked with <a href="https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS"><code>...over (order by ...)</code></a>, is handy for showing the position number of this particular row against its peers when the peers are ordered by some sort of&nbsp;ordering.</p>
<p>Through some trial and error, here&#8217;s a spelling letting us compare the closest 30 by-way-of-great-circle versus where those points would have ranked if using the Cartesian distance, while also being fast (&lt; 2ms). I used CTEs to separate out each separate plannable-by-<span class="caps">KNN</span>-search path for each different <span class="caps">KNN</span>-supporting index, then join the together by picture id to cross-compare. The limits within both the <code>OVER</code>  and <code>LIMIT</code> clauses happened to give me complete data projected here. Your random dataset may require different&nbsp;values.</p>
<div class="highlight"><pre><span></span><span class="gp">poor_gis=#</span> <span class="k">with</span> <span class="n">by_cube</span> <span class="k">as</span> <span class="p">(</span>

    <span class="cm">/* id, great-circle distance, rank (position of</span>
<span class="cm">                        row in the set) for closest 30</span>
<span class="cm">                        by great-circle metrics */</span>

    <span class="k">select</span> <span class="n">id</span><span class="p">,</span>

    <span class="n">ll_to_earth</span><span class="p">(</span><span class="n">geocode_point</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span> <span class="n">geocode_point</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
       <span class="o">&lt;-&gt;</span> <span class="n">ll_to_earth</span><span class="p">(</span><span class="mf">48.6482342518866</span><span class="p">,</span> <span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">)</span>
            <span class="k">as</span> <span class="n">cube_3d_meters</span><span class="p">,</span>

    <span class="n">rank</span><span class="p">()</span> <span class="k">over</span> <span class="p">(</span><span class="k">order</span> <span class="k">by</span>
            <span class="n">ll_to_earth</span><span class="p">(</span><span class="n">geocode_point</span><span class="p">[</span><span class="mf">1</span><span class="p">],</span> <span class="n">geocode_point</span><span class="p">[</span><span class="mf">0</span><span class="p">])</span>
                <span class="o">&lt;-&gt;</span> <span class="n">ll_to_earth</span><span class="p">(</span><span class="mf">48.6482342518866</span><span class="p">,</span> <span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">)</span>
                <span class="k">rows</span> <span class="k">between</span> <span class="mf">30</span> <span class="k">preceding</span> <span class="k">and</span> <span class="k">current</span> <span class="k">row</span><span class="p">)</span>
       <span class="k">as</span> <span class="n">cube_rank</span>

    <span class="k">from</span> <span class="n">image</span>
    <span class="k">order</span> <span class="k">by</span> <span class="mf">2</span> <span class="k">limit</span> <span class="mf">30</span>

<span class="p">),</span> <span class="n">by_cartesian</span> <span class="k">as</span> <span class="p">(</span>

        <span class="cm">/* id, flat-earth-radian distance,</span>
<span class="cm">                        rank for closest 60</span>
<span class="cm">                        by great-circle metrics */</span>

        <span class="k">select</span> <span class="n">id</span><span class="p">,</span>

        <span class="n">geocode_point</span> <span class="o">&lt;-&gt;</span> <span class="nb">point</span><span class="p">(</span><span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">,</span> <span class="mf">48.6482342518866</span><span class="p">)</span>
            <span class="k">as</span> <span class="n">flat_radians</span><span class="p">,</span>

        <span class="n">rank</span><span class="p">()</span> <span class="k">over</span> <span class="p">(</span><span class="k">order</span> <span class="k">by</span>
                <span class="n">geocode_point</span> <span class="o">&lt;-&gt;</span> <span class="nb">point</span><span class="p">(</span><span class="o">-</span><span class="mf">89.8555855080485</span><span class="p">,</span> <span class="mf">48.6482342518866</span><span class="p">)</span>
                <span class="k">rows</span> <span class="k">between</span> <span class="mf">60</span> <span class="k">preceding</span> <span class="k">and</span> <span class="k">current</span> <span class="k">row</span><span class="p">)</span>
            <span class="k">as</span> <span class="n">cartesian_rank</span>

        <span class="k">from</span> <span class="n">image</span>
        <span class="k">order</span> <span class="k">by</span> <span class="mf">2</span> <span class="k">limit</span> <span class="mf">60</span>
<span class="p">)</span>

<span class="cm">/* Join both together, but handling if a by-great-circle top 30 point</span>
<span class="cm">    isn&#39;t in the top 60 by-flat-earth set */</span>

<span class="k">select</span> <span class="n">bcu</span><span class="mf">.</span><span class="n">id</span><span class="p">,</span> <span class="n">bcu</span><span class="mf">.</span><span class="n">cube_3d_meters</span> <span class="k">as</span> <span class="n">g_c_dist</span><span class="p">,</span> <span class="n">bcu</span><span class="mf">.</span><span class="n">cube_rank</span> <span class="k">as</span> <span class="n">by_cube</span><span class="p">,</span>
            <span class="n">bct</span><span class="mf">.</span><span class="n">flat_radians</span> <span class="k">as</span> <span class="n">rad_dist</span><span class="p">,</span> <span class="n">bct</span><span class="mf">.</span><span class="n">cartesian_rank</span> <span class="k">as</span> <span class="n">by_flat</span><span class="p">,</span>
            <span class="n">cartesian_rank</span> <span class="o">-</span> <span class="n">cube_rank</span> <span class="k">as</span> <span class="n">rank_diff</span>
<span class="k">from</span> <span class="n">by_cube</span> <span class="n">bcu</span>
    <span class="k">left</span> <span class="k">join</span> <span class="n">by_cartesian</span> <span class="n">bct</span>
        <span class="k">using</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>

<span class="k">order</span> <span class="k">by</span> <span class="mf">3</span><span class="p">;</span>

<span class="go">   id   |     g_c_dist     | by_cube |     rad_dist      | by_flat | rank_diff</span>
<span class="go">--------+------------------+---------+-------------------+---------+-----------</span>
<span class="go"> 598209 | 9454.35088669499 |       1 | 0.119530605833611 |       1 |         0</span>
<span class="go"> 515449 |  11289.741773158 |       2 | 0.142353443267662 |       2 |         0</span>
<span class="go"> 499558 | 24789.7673198475 |       3 | 0.336057680731329 |       5 |         2</span>
<span class="go"> 141547 |  30840.150001606 |       4 | 0.326047985932906 |       4 |         0</span>
<span class="go"> 220796 | 33376.7027558878 |       5 | 0.318078456991974 |       3 |        -2</span>
<span class="go"> 780164 | 34126.7112106395 |       6 | 0.400569721968307 |       7 |         1</span>
<span class="go"> 139998 | 38427.3933242223 |       7 | 0.347431064471505 |       6 |        -1</span>
<span class="go"> 419038 | 42641.1099952202 |       8 | 0.414454739876302 |       8 |         0</span>
<span class="go"> 260518 | 46821.4967775541 |       9 | 0.635773466990049 |      19 |        10</span>
<span class="go"> 689067 | 49951.4480842041 |      10 | 0.677215642366855 |      21 |        11</span>
<span class="go">  40360 | 50417.8640957375 |      11 | 0.486064134504151 |       9 |        -2</span>
<span class="go"> 170628 | 53237.0844513251 |      12 | 0.623723300321995 |      18 |         6</span>
<span class="go"> 732650 | 53492.9726637618 |      13 | 0.574323584575311 |      15 |         2</span>
<span class="go"> 787789 | 55461.1710907472 |      14 | 0.598400501558983 |      17 |         3</span>
<span class="go"> 968891 |  55778.540935383 |      15 | 0.503582023669556 |      10 |        -5</span>
<span class="go"> 695971 | 56695.5009533287 |      16 | 0.509681921765089 |      11 |        -5</span>
<span class="go"> 831892 | 57272.5646100655 |      17 | 0.550748722184749 |      13 |        -4</span>
<span class="go"> 238526 | 59694.1205504939 |      18 | 0.806711096834358 |      24 |         6</span>
<span class="go"> 476373 | 60509.6480280316 |      19 | 0.550708332205125 |      12 |        -7</span>
<span class="go"> 388590 | 60655.8889045443 |      20 | 0.570266337375791 |      14 |        -6</span>
<span class="go"> 346148 | 63336.0461109318 |      21 | 0.576721033876329 |      16 |        -5</span>
<span class="go"> 270798 |  63864.771530601 |      22 | 0.692437548795166 |      22 |         0</span>
<span class="go"> 340999 | 68912.4352427674 |      23 | 0.815154253360147 |      25 |         2</span>
<span class="go"> 747903 | 69399.6477783806 |      24 | 0.636585477224388 |      20 |        -4</span>
<span class="go"> 166103 | 72992.9160155629 |      25 | 0.965187191143913 |      39 |        14</span>
<span class="go">  38988 | 73126.8620122719 |      26 | 0.817025498072814 |      26 |         0</span>
<span class="go"> 808750 | 73911.7287023302 |      27 | 0.906290409593806 |      35 |         8</span>
<span class="go"> 504684 | 74466.0850680456 |      28 | 0.886736739457095 |      33 |         5</span>
<span class="go"> 279756 | 74972.2174697155 |      29 | 0.941260697642388 |      38 |         9</span>
<span class="go"> 546620 | 78587.8861189611 |      30 | 0.940726308160501 |      37 |         7</span>
<span class="go">(30 rows)</span>
</pre></div>


<p>You can see that as the great circle distance grows, said point&#8217;s as-ordered-by flat-earth radian distance position has more and more errors. The largest observed in this sample was being off by fourteen positions &#8212;- the point deemed 25th closest by great circle distance was thought to be 39th closest by flat-earth radian&nbsp;distance.</p>
<h2>End of Part&nbsp;One</h2>
<p>We&#8217;ve seen how to tack on some <span class="caps">GIS</span> features onto a dataset / web application from the <em>bottom up</em> &#8212;- starting with the simplest possible representation allowing for fast spatial queries, then expanded our technological requirements minimally as we considered improving our not-quite-accurate <span class="caps">KNN</span> query results. We discussed the limitations in our implementation, namely needing two separate <span class="caps">SP</span>-GiST indices to support either &#8220;all points within a lat/long-specified rectangle&#8221; as well as relatively-accurate &#8220;nearest K points from an arbitrary point&#8221; queries. We&#8217;ve touched on many of the complexity issues cartographers and <span class="caps">GIS</span> systems face when projecting the surface of the Earth onto either a grid, or even as points in a simplified 3D space. We&#8217;ve demonstrated that PostGIS <em>is not strictly needed</em> for this sort of basic geospatial&nbsp;work.</p>
<p>That said, in the next post, we&#8217;ll discuss use cases which will require PostGIS, migrate our schema to support PostGIS modeling of our points, then compare performance, index sizes, etc. versus the additional concepts needing understanding in order to get basic PostGIS&nbsp;running.</p>
<h2>About The&nbsp;Author</h2>
<p>James was technical team leader of a rental real-estate site from the early 2000s through 2016. This geospatial series tracks a similar path to how our team first adopted primitive-but-fast <span class="caps">GIS</span> support within PostGIS proper, then later on adopting PostGIS when use cases&nbsp;required.</p>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=Earthdistance and Cube: Simple, Fast, Approximate Spatial PostgreSQL Without&nbsp;PostGIS&amp;url=../drafts/simple-spatial-postgres-sans-postgis.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=../drafts/simple-spatial-postgres-sans-postgis.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=../drafts/simple-spatial-postgres-sans-postgis.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="../tag/postgresql">PostgreSQL</a><a href="../tag/postgis">PostGIS</a>                </aside>

                <div class="clear"></div>

 

                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>


  <script type="text/javascript" src="../theme/js/script.js"></script>

</body>
</html>